<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atomic Model</title>
    <link rel="stylesheet" href="css/main.css">
    <!-- Import Threejs -->
    <script type="text/javascript" src="three.js-master/build/three.js"></script>
</head>
<body>

    <!-- Some fragments of code were retrieved from the following sources: -->
    <!-- 1. https://www.youtube.com/channel/UCC7y8uQQXtSxXDGle76HAxw -->
    <!-- 2. https://stackoverflow.com/questions/13039589/rotate-the-camera-around-an-object-using-the-arrow-keys-in-three-js -->
    <!-- 3. https://stackoverflow.com/questions/29202091/three-js-keyboard-rotation -->
    <!-- 4. https://www.youtube.com/watch?v=6oFvqLfRnsU&ab_channel=DesignCourse -->

    <script>
        // Create the scene
        var scene = new THREE.Scene();

        // Axes
        const axesHelper = new THREE.AxesHelper(15);
        scene.add(axesHelper);
        
        const light = new THREE.PointLight( 0xffffff, 10, 2);
        light.position.set( 0, 20, 0 );
        scene.add( light );
        var theta = 0;

        // Add a texture to the background
        const loader = new THREE.TextureLoader();
        loader.load("./textures/background.jpg", (texture) => {
            scene.background = texture;
        })

        // Add a Perspective Camera
        var camera = new THREE.PerspectiveCamera(
            75,                                       // Field of View
            window.innerWidth/window.innerHeight,     // Aspect ratio
            0.1,                                      // Near (default value)
            2000                                      // Far (default value)
        );

        camera.position.z = 100;

        // Renderer
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create the protons
        loader.load("./textures/proton.jpg", texture => {
            const proton_geometry = new THREE.SphereGeometry(5, 50, 50);
            const proton_material = new THREE.MeshBasicMaterial({ map: texture });

            const proton_1 = new THREE.Mesh(proton_geometry, proton_material);
            const proton_2 = new THREE.Mesh(proton_geometry, proton_material);
            const proton_3 = new THREE.Mesh(proton_geometry, proton_material);
            const proton_4 = new THREE.Mesh(proton_geometry, proton_material);
            const proton_5 = new THREE.Mesh(proton_geometry, proton_material);

            proton_1.position.x = 0;
            proton_1.position.y = 2 * 5 * Math.cos(Math.PI / 4);
            proton_1.position.z = 0;

            proton_2.position.x = 0;
            proton_2.position.y = 0;
            proton_2.position.z = 2 * 5 * Math.cos(Math.PI / 4);

            proton_3.position.x = 2 * 5 * Math.cos(Math.PI / 4);
            proton_3.position.y = 0;
            proton_3.position.z = 0;

            scene.add(proton_1);
            scene.add(proton_2);
            scene.add(proton_3);
        });
        
        // Create the neutrons
        loader.load("./textures/neutron.jpg", texture => {
            const neutron_geometry = new THREE.SphereGeometry(5, 50, 50);
            const neutron_material = new THREE.MeshBasicMaterial({ map: texture });

            const neutron_1 = new THREE.Mesh(neutron_geometry, neutron_material); 
            const neutron_2 = new THREE.Mesh(neutron_geometry, neutron_material); 
            const neutron_3 = new THREE.Mesh(neutron_geometry, neutron_material); 

            neutron_1.position.x = 0;
            neutron_1.position.y = - 2 * 5 * Math.cos(Math.PI / 4);
            neutron_1.position.z = 0;

            neutron_2.position.x = 0;
            neutron_2.position.y = 0;
            neutron_2.position.z = - 2 * 5 * Math.cos(Math.PI / 4);

            neutron_3.position.x = - 2 * 5 * Math.cos(Math.PI / 4);
            neutron_3.position.y = 0;
            neutron_3.position.z = 0;

            scene.add(neutron_1);
            scene.add(neutron_2);
            scene.add(neutron_3);
        });

        //Create electrons
        var cover = new THREE.MeshNormalMaterial();
        var electron_geometry = new THREE.SphereGeometry(5, 100, 100);
        
        var electron1 = new THREE.Mesh(electron_geometry, cover);
        scene.add(electron1);
        electron1.position.set(-20,20,0);

        var electron2 = new THREE.Mesh(electron_geometry, cover);
        scene.add(electron2);
        electron2.position.set(20,-20,0);
        
        var electron3 = new THREE.Mesh(electron_geometry, cover);
        scene.add(electron3);
        electron3.position.set(30,30,0);

        var electron4 = new THREE.Mesh(electron_geometry, cover);
        scene.add(electron4);
        electron4.position.set(0,0,30);

        var electron5 = new THREE.Mesh(electron_geometry, cover);
        scene.add(electron5);
        electron5.position.set(-30,-30,0);

        var electron6 = new THREE.Mesh(electron_geometry, cover);
        scene.add(electron6);
        electron6.position.set(0,0,-30);
        
        var electron7 = new THREE.Mesh(electron_geometry, cover);
        scene.add(electron7);
        electron7.position.set(Math.cos(18)*30, Math.cos(18)*30, Math.sin(18)*30);
        
        var electron8 = new THREE.Mesh(electron_geometry, cover);
        scene.add(electron8);
        electron8.position.set(-Math.cos(18)*30, -Math.cos(18)*30, -Math.sin(18)*30);
        
        var electron9 = new THREE.Mesh(electron_geometry, cover);
        scene.add(electron9);
        electron9.position.set(Math.cos(18)*30, Math.cos(18)*30, -Math.sin(18)*30);
        
        var electron10 = new THREE.Mesh(electron_geometry, cover);
        scene.add(electron10);
        electron10.position.set(-Math.cos(18)*30, -Math.cos(18)*30, Math.sin(18)*30);
        
        var v_electron1 = new THREE.Mesh(electron_geometry, cover);
        scene.add(v_electron1);
        v_electron1.position.set(Math.cos(18)*40, 0, Math.sin(18)*40);

        var v_electron2 = new THREE.Mesh(electron_geometry, cover);
        scene.add(v_electron2);
        v_electron2.position.set(-Math.cos(18)*40, 0, Math.sin(18)*40);

        var v_electron3 = new THREE.Mesh(electron_geometry, cover);
        scene.add(v_electron3);
        v_electron3.position.set(0, 0, 40);
        
        
        // renderer.render(scene, camera);
        
        // Create an animation
        var clock = new THREE.Clock();
        var animate = function() {
            requestAnimationFrame(animate);
            var t = clock.getElapsedTime();
            
            v_electron1.position.x = Math.cos(2*t) * 40;
            v_electron1.position.y = Math.cos(2*t) * 0;
            v_electron1.position.z = Math.sin(2*t) * 40;
            
            v_electron2.position.x = Math.cos(3*t) * 40;
            v_electron2.position.y = Math.cos(3*t) * 0;
            v_electron2.position.z = Math.sin(3*t) * 40;

            v_electron3.position.x = Math.cos(5*t) * 40;
            v_electron3.position.y = Math.cos(5*t) * 0;
            v_electron3.position.z = Math.sin(5*t) * 40;
            
            if (window.isLeftDown) {
                camera.position.x = - 100 * Math.cos(theta);
                camera.position.y = camera.position.y;
                camera.position.z = - 100 * Math.sin(theta);
            }

            else if (window.isRightDown) {
                camera.position.x = 100 * Math.cos(theta);
                camera.position.y = camera.position.y;
                camera.position.z = 100 * Math.sin(theta);
            }

            else if (window.isUpDown) {
                camera.position.x = camera.position.x; 
                camera.position.y = 100 * Math.sin(theta);
                camera.position.z = 100 * Math.cos(theta);
            }

            else if (window.isDownDown) {
                camera.position.x = camera.position.x; 
                camera.position.y = - 100 * Math.sin(theta);
                camera.position.z = - 100 * Math.cos(theta);
            }

            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }

        // Key listeners
        function handleKeyDown(event) {
            // Left arrow pressed
            if (event.keyCode === 37) {
                theta += 1;
                window.isLeftDown = true;
            }

            // Right arrow pressed
            else if (event.keyCode === 39) {
                theta -= 1;
                window.isRightDown = true;
            }

            // Up arrow pressed
            else if (event.keyCode === 38) {
                theta += 1;
                window.isUpDown = true;
            }

            // Down arrow pressed
            else if (event.keyCode === 40) {
                theta -= 1;
                window.isDownDown = true;
            }
        }

        function handleKeyUp(event) {
            // Left arrow released
            if (event.keyCode === 37) {
                window.isLeftDown = false;
            }

            // Right arrow released
            else if (event.keyCode === 39) {
                window.isRightDown = false;
            }

            // Up arrow released
            else if (event.keyCode === 38) {
                window.isUpDown = false;
            }

            // Down arrow released
            else if (event.keyCode === 40) {
                window.isDownDown = false;
            }
        }

        window.addEventListener('keydown', handleKeyDown, false);
        window.addEventListener('keyup', handleKeyUp, false);
        

        animate();
    </script>

</body>
</html>