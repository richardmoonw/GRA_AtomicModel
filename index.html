<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atomic Model</title>
    <link rel="stylesheet" href="css/main.css">
    <!-- Import Threejs -->
    <script src="three.js-master/build/three.js"></script>
    <script src="three.js-master/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <!-- Some fragments of code were retrieved from the following sources: -->
    <!-- 1. https://www.youtube.com/channel/UCC7y8uQQXtSxXDGle76HAxw -->
    <!-- 2. https://stackoverflow.com/questions/13039589/rotate-the-camera-around-an-object-using-the-arrow-keys-in-three-js -->
    <!-- 3. https://stackoverflow.com/questions/29202091/three-js-keyboard-rotation -->
    <!-- 4. https://www.youtube.com/watch?v=6oFvqLfRnsU&ab_channel=DesignCourse -->
    <!-- 5. https://www.aaron-gray.com/three-js-tutorial-building-an-atom/ -->

    <script>
        // Create the scene
        var scene = new THREE.Scene();
        
        const light = new THREE.DirectionalLight( 0xdddddd, 1);
        light.position.set(50, 50, 50);
        scene.add(light);

        const light_2 = new THREE.DirectionalLight( 0xdddddd, 1);
        light_2.position.set(-50, 50, -50);
        scene.add(light_2);

        // Helper to see the lights
        // const helper = new THREE.DirectionalLightHelper( light, 5 );
        // scene.add( helper );

        // Add a texture to the background
        const loader = new THREE.TextureLoader();
        loader.load("./textures/background.jpg", (texture) => {
            scene.background = texture;
        })

        // Add a Perspective Camera
        var camera = new THREE.PerspectiveCamera(
            75,                                       // Field of View
            window.innerWidth/window.innerHeight,     // Aspect ratio
            0.1,                                      // Near (default value)
            2000                                      // Far (default value)
        );

        camera.position.z = 75;
        // Renderer
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // Create the protons
        loader.load("./textures/proton.jpg", texture => {
            const radius = 1.5;
            const proton_geometry = new THREE.SphereGeometry(radius, 50, 50);
            const proton_material = new THREE.MeshPhongMaterial({ map: texture });

            const proton_1 = new THREE.Mesh(proton_geometry, proton_material);
            const proton_2 = new THREE.Mesh(proton_geometry, proton_material);
            const proton_3 = new THREE.Mesh(proton_geometry, proton_material);
            const proton_4 = new THREE.Mesh(proton_geometry, proton_material);
            const proton_5 = new THREE.Mesh(proton_geometry, proton_material);
            const proton_6 = new THREE.Mesh(proton_geometry, proton_material);
            const proton_7 = new THREE.Mesh(proton_geometry, proton_material);
            const proton_8 = new THREE.Mesh(proton_geometry, proton_material);
            const proton_9 = new THREE.Mesh(proton_geometry, proton_material);
            const proton_10 = new THREE.Mesh(proton_geometry, proton_material);
            const proton_11 = new THREE.Mesh(proton_geometry, proton_material);
            const proton_12 = new THREE.Mesh(proton_geometry, proton_material);
            const proton_13 = new THREE.Mesh(proton_geometry, proton_material);

            proton_1.position.x = 2 * radius + radius * Math.cos(Math.PI/4);
            proton_1.position.y = 0;
            proton_1.position.z = 0;

            proton_2.position.x = - 2 * radius - radius * Math.cos(Math.PI/4);
            proton_2.position.y = 0;
            proton_2.position.z = 0;

            proton_3.position.x = 0;
            proton_3.position.y = 2 * radius + radius * Math.sin(Math.PI/4);
            proton_3.position.z = 0;
            
            proton_4.position.x = 0;
            proton_4.position.y = - 2 * radius - radius * Math.sin(Math.PI/4);
            proton_4.position.z = 0;
            
            proton_5.position.x = - 2 * radius * Math.cos(Math.PI/4);
            proton_5.position.y = 0;
            proton_5.position.z = 2 * radius * Math.cos(Math.PI/4);

            proton_6.position.x = 0;
            proton_6.position.y = 0;
            proton_6.position.z = 2 * radius + radius * Math.sin(Math.PI/4);

            proton_7.position.x = 2 * radius * Math.cos(Math.PI/4);
            proton_7.position.y = 0;
            proton_7.position.z = 2 * radius * Math.cos(Math.PI/4);

            proton_8.position.x = radius;
            proton_8.position.y = 2 * radius * Math.cos(Math.PI/4);
            proton_8.position.z = 2 * radius * Math.cos(Math.PI/4);

            proton_9.position.x = radius;
            proton_9.position.y = - 2 * radius * Math.cos(Math.PI/4);
            proton_9.position.z = 2 * radius * Math.cos(Math.PI/4);

            proton_10.position.x = radius;
            proton_10.position.y = 2 * radius * Math.cos(Math.PI/4);
            proton_10.position.z = -2 * radius * Math.cos(Math.PI/4);
            
            proton_11.position.x = radius;
            proton_11.position.y = - 2 * radius * Math.cos(Math.PI/4);
            proton_11.position.z = - 2 * radius * Math.cos(Math.PI/4);

            proton_12.position.x = radius;
            proton_12.position.y = radius;
            proton_12.position.z = 0;

            proton_13.position.x = -radius;
            proton_13.position.y = -radius;
            proton_13.position.z = 0;

            scene.add(proton_1);
            scene.add(proton_2);
            scene.add(proton_3);
            scene.add(proton_4);
            scene.add(proton_5);
            scene.add(proton_6);
            scene.add(proton_7);
            scene.add(proton_8);
            scene.add(proton_9);
            scene.add(proton_10);
            scene.add(proton_11);
            scene.add(proton_12);
            scene.add(proton_13);
        });
        
        // Create the neutrons
        loader.load("./textures/neutron.jpg", texture => {
            const radius = 1.5;
            const neutron_geometry = new THREE.SphereGeometry(radius, 50, 50);
            const neutron_material = new THREE.MeshPhongMaterial({ map: texture });

            const neutron_1 = new THREE.Mesh(neutron_geometry, neutron_material); 
            const neutron_2 = new THREE.Mesh(neutron_geometry, neutron_material); 
            const neutron_3 = new THREE.Mesh(neutron_geometry, neutron_material); 
            const neutron_4 = new THREE.Mesh(neutron_geometry, neutron_material); 
            const neutron_5 = new THREE.Mesh(neutron_geometry, neutron_material); 
            const neutron_6 = new THREE.Mesh(neutron_geometry, neutron_material); 
            const neutron_7 = new THREE.Mesh(neutron_geometry, neutron_material); 
            const neutron_8 = new THREE.Mesh(neutron_geometry, neutron_material); 
            const neutron_9 = new THREE.Mesh(neutron_geometry, neutron_material); 
            const neutron_10 = new THREE.Mesh(neutron_geometry, neutron_material); 
            const neutron_11 = new THREE.Mesh(neutron_geometry, neutron_material); 
            const neutron_12 = new THREE.Mesh(neutron_geometry, neutron_material); 
            const neutron_13 = new THREE.Mesh(neutron_geometry, neutron_material);
            const neutron_14 = new THREE.Mesh(neutron_geometry, neutron_material); 

            neutron_1.position.x = 2 * radius * Math.cos(Math.PI/4);
            neutron_1.position.y = 2 * radius * Math.sin(Math.PI/4);
            neutron_1.position.z = 0;

            neutron_2.position.x = -2 * radius * Math.cos(Math.PI/4);
            neutron_2.position.y = 2 * radius * Math.cos(Math.PI/4);
            neutron_2.position.z = 0;

            neutron_3.position.x = - 2 * radius * Math.cos(Math.PI/4);
            neutron_3.position.y = - 2 * radius * Math.cos(Math.PI/4);
            neutron_3.position.z = 0;

            neutron_4.position.x = 2 * radius * Math.cos(Math.PI/4);
            neutron_4.position.y = - 2 * radius * Math.cos(Math.PI/4);
            neutron_4.position.z = 0;

            neutron_5.position.x = - 2 * radius * Math.cos(Math.PI/4);
            neutron_5.position.y = 0;
            neutron_5.position.z = - 2 * radius * Math.cos(Math.PI/4);

            neutron_6.position.x = 0;
            neutron_6.position.y = 0;
            neutron_6.position.z = - 2 * radius - radius * Math.sin(Math.PI/4);

            neutron_7.position.x = 2 * radius * Math.cos(Math.PI/4);
            neutron_7.position.y = 0;
            neutron_7.position.z = - 2 * radius * Math.cos(Math.PI/4);

            neutron_8.position.x = - radius;
            neutron_8.position.y = 2 * radius * Math.cos(Math.PI/4);
            neutron_8.position.z = 2 * radius * Math.cos(Math.PI/4);

            neutron_9.position.x = - radius;
            neutron_9.position.y = - 2 * radius * Math.cos(Math.PI/4);
            neutron_9.position.z = 2 * radius * Math.cos(Math.PI/4);

            neutron_10.position.x = - radius;
            neutron_10.position.y = 2 * radius * Math.cos(Math.PI/4);
            neutron_10.position.z = - 2 * radius * Math.cos(Math.PI/4);

            neutron_11.position.x = - radius;
            neutron_11.position.y = - 2 * radius * Math.cos(Math.PI/4);
            neutron_11.position.z = - 2 * radius * Math.cos(Math.PI/4);

            neutron_12.position.x = radius;
            neutron_12.position.y = -radius;
            neutron_12.position.z = 0;

            neutron_13.position.x = - radius;
            neutron_13.position.y = radius;
            neutron_13.position.z = 0;

            neutron_14.position.x = 0;
            neutron_14.position.y = 0;
            neutron_14.position.z = 0;

            scene.add(neutron_1);
            scene.add(neutron_2);
            scene.add(neutron_3);
            scene.add(neutron_4);
            scene.add(neutron_5);
            scene.add(neutron_6);
            scene.add(neutron_7);
            scene.add(neutron_8);
            scene.add(neutron_9);
            scene.add(neutron_10);
            scene.add(neutron_11);
            scene.add(neutron_12);
            scene.add(neutron_13);
            scene.add(neutron_14);
        });

        //Create electrons
        var v_electron_1;
        var v_electron_2;
        var v_electron_3;
        loader.load("./textures/electron.jpg", texture => {
            const radius = 1;
            const electron_geometry = new THREE.SphereGeometry(radius, 100, 100);
            const electron_material = new THREE.MeshPhongMaterial({ map: texture });
            var electron_1 = new THREE.Mesh(electron_geometry, electron_material);
            var electron_2 = new THREE.Mesh(electron_geometry, electron_material);
            var electron_3 = new THREE.Mesh(electron_geometry, electron_material);
            var electron_4 = new THREE.Mesh(electron_geometry, electron_material);
            var electron_5 = new THREE.Mesh(electron_geometry, electron_material);
            var electron_6 = new THREE.Mesh(electron_geometry, electron_material);
            var electron_7 = new THREE.Mesh(electron_geometry, electron_material);
            var electron_8 = new THREE.Mesh(electron_geometry, electron_material);
            var electron_9 = new THREE.Mesh(electron_geometry, electron_material);
            var electron_10 = new THREE.Mesh(electron_geometry, electron_material);
            
            v_electron_1 = new THREE.Mesh(electron_geometry, electron_material);
            v_electron_2 = new THREE.Mesh(electron_geometry, electron_material);
            v_electron_3 = new THREE.Mesh(electron_geometry, electron_material);

            scene.add(electron_1);
            scene.add(electron_2);
            scene.add(electron_3);
            scene.add(electron_4);
            scene.add(electron_5);
            scene.add(electron_6);
            scene.add(electron_7);
            scene.add(electron_8);
            scene.add(electron_9);
            scene.add(electron_10);
            scene.add(v_electron_1);
            scene.add(v_electron_2);
            scene.add(v_electron_3);

            electron_1.position.set(-5,5,0);
            electron_2.position.set(5,-5,0);
            electron_3.position.set(Math.cos(Math.PI/4)* 13, Math.cos(Math.PI/4) * 13,0);
            electron_4.position.set(0,0,13);
            electron_5.position.set(-Math.cos(Math.PI/4)* 13, -Math.cos(Math.PI/4)* 13,0);
            electron_6.position.set(0,0,-13);
            electron_7.position.set(Math.cos(Math.PI/4)*10.5, Math.cos(Math.PI/4)*10.5, Math.sin(Math.PI/4)*10.5);
            electron_8.position.set(-Math.cos(Math.PI/4)*10.5, -Math.cos(Math.PI/4)*10.5, -Math.sin(Math.PI/4)*10.5);
            electron_9.position.set(Math.cos(Math.PI/4)*10.5, Math.cos(Math.PI/4)*10.5, -Math.sin(Math.PI/4)*10.5);
            electron_10.position.set(-Math.cos(Math.PI/4)*10.5, -Math.cos(Math.PI/4)*10.5, Math.sin(Math.PI/4)*10.5);
        });
        
        // Create the energy layers
        const material = new THREE.MeshBasicMaterial( { color: 0xffffff} );

        const geometry_1 = new THREE.TorusGeometry(7, 0.25, 16, 100 );
        const geometry_2 = new THREE.TorusGeometry(13, 0.25, 16, 100 );
        const geometry_3 = new THREE.TorusGeometry(20, 0.25, 16, 100 );

        const torus_1 = new THREE.Mesh(geometry_1, material);
        const torus_2 = new THREE.Mesh(geometry_2, material);
        const torus_3 = new THREE.Mesh(geometry_3, material);

        // Second energy layer
        torus_2.rotateY(-Math.PI/2);
        torus_2.rotateX(-Math.PI/4);

        // Third energy layer
        torus_3.rotation.x = Math.PI/2;

        scene.add(torus_1);
        scene.add(torus_2);
        scene.add(torus_3);

        // Create an animation
        var clock = new THREE.Clock();
        var camera_pos = 75
        
        var animate = function() {

            requestAnimationFrame(animate);
            var t = clock.getElapsedTime();

            controls.update();

            //Position = cos || sin(time + position in radians) * radius
            v_electron_1.position.x = Math.cos(2*t) * 20;
            v_electron_1.position.z = Math.sin(2*t) * 20;
            
            v_electron_2.position.x = Math.cos((2*t) + (120*Math.PI/180)) * 20;
            v_electron_2.position.z = Math.sin((2*t) + (120*Math.PI/180)) * 20;

            v_electron_3.position.x = Math.cos((2*t) + (240*Math.PI/180)) * 20;
            v_electron_3.position.z = Math.sin((2*t) + (240*Math.PI/180)) * 20;

            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            var width = window.innerWidth;
            var height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width/height;
            camera.updateProjectionMatrix;
        })


        animate();

        
    </script>

</body>
</html>